; 分支语句练习
; 判断一个数X是正数，负数还是0
; 条件转移法
data segment
    X dw -1
    res db ? ; 定义一个名为X类型为dw(1)值为-1的变量，和一个名为res类型为db无初始值的变量
data ends

code segment
    assume cs:code, ds:data
start:
    mov ax, data
    mov ds, ax
    ; 以上为固定结构
    mov ax, X ; 将X的值放到ax寄存器中

    ; 通过判断X的取值来跳转(2)到不同的代码
    cmp ax, 0
    je zero ; 判断ax的值和0是否相等(3)，如果相等则跳转到zero

    shl ax, 1
    jnc positive ; 判断ax是否为正数(4), 如果为正数则跳转到positive

    shl ax, 1
    jc negative ; 如果为负数跳转到negative

zero:
    mov res, '0' ; 将字符0存入res中
    jmp over ; 直接跳转到over
positive:
    mov res, '+' ;同上
    jmp over
negative:
    mov res, '-' ;同上
    jmp over
over:
    mov dl, res ; 将结果存到dl中，用来给02号系统功能调用
    mov ah, 02h ; 调用02号系统功能(5)打印出dl中的字符
    int 21h

    mov ah, 4ch ; 调用4c号系统功能结束程序
    int 21h
code ends
end start

; (1)dw和db数据类型，在汇编中不分int, char, double之类的类型，而是简单的将数据类型按照内存的大小来划分的
; db为内存为一个字节的类型，dw为内存为两个字节的类型。
; 一个字节有8位，所以db的一共有2^8种取值，00000000 ~ 11111111，在汇编中用16进制表示就是00~ff
; 同理dw一共有2^16种取值，从0000~ffff

; (2)跳转：
; 在程序运行中，cs寄存器会储存当前正在运行的代码所在的代码段的地址，ip寄存器会存储当前代码的偏移量
; 通过cs和ip这两个寄存器可以确定下一步要执行的语句
; cs和ip是很重要的，所以不允许直接通过mov语句去给cs和ip赋值
; 正常情况下语句是一行一行依次执行的
; 通过jmp(3)等一些跳转命令可以根据要跳转的目标位置而改变cs和ip寄存器的值，从而改变下一步要执行的语句
; 进而达到在代码间跳转的效果，不过以我们目前的水平基本上改变不了cs，最多就改变改变ip

; (3)使用 cmp A, B 和 je C 这两句命令可以实现若A和B的值相等则跳转到C处的功能
; 具体的内部原理暂时不需要去深究，类似的还有
; shl A, 1 和 jnc C 的作用是如果A为正数则跳转到C处
; shl A, 1 和 jc C 的作用是如果A为负数则跳转到C处
; cmp A, B 和 ja C 的作用是如果A大于B则跳转到C处
; cmp A, B 和 jb C 的作用是如果A小于B则跳转到C处
; jmp C 的作用是直接跳转到C处

; (4)为了计算方便等原因，我们人为的将这65536个数分为正数和负数
; 并且将第一个二进制为规定为'符号位'，符号位为0代表该数为正数，符号位为1代表该数为负数
; 对于两个字节的数来说
; 值在0000000000000000(0) ~ 0111111111111111(2^15 - 1)中的数被定义为正数
; 值在1000000000000000(-2^15) ~ 1111111111111111(-1)中的数被定义为负数
; 详情请搜索源码，补码，反码，移码相关定义和由来
; 注释4以上内容在计算机导论，程序设计基础，计算机组成原理等多门课中都有讲过，如果不懂请自己反思一下
; 类型为dw的变量内存为两个字节，所以就有了dw的取值范围-32768~32767，db类型同理范围为-128~127

; (5)02号系统功能，可以打印出存在dl寄存器中的值所对应的ASCII字符
